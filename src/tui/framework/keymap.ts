import { mergeLeft } from '@whimbrel/walk'
import { Controller } from './controller'

/**
 * Map of key identifiers or key patterns to key functionality.
 *
 * Key identifiers symbols are expressed as `q`, `C-c`, `S-return`, `escape`
 * or `return`.
 *
 * Key patterns are regular expressions enclosed in slashes, e.g. `/[a-z]/`.
 */
export type KeyMap = Record<string, KeyMapping>

export type KeyIdentifier = string | string[]

export type KeyMapping = {
  propagate?: boolean
  handler: Function
} & KeyLegend

export interface KeyLegend {
  legend?: string
  /**
   * Defines the `category` of this mapped keystroke. When a KeystrokeLegend
   * is computed, KeyMappings of the same category will be grouped together.
   */
  category?: string
  /**
   * Defines a `group` for this mapped keystroke. When a KeystrokeLegend
   * is computed, KeyMappings belonging to the same group will be merged into
   * a single entry, ie, if mappings for keys `up` and `down` both specify
   * 'Navigation' as their group, they will appear as 'up/down = Navigate'
   */
  group?: string
  /**
   * The handler function that will be invoked when the mapped keystroke is
   * performed.
   */
}

export interface LegendGroup {
  symbol: string
  description: string
}

export interface LegendKey {
  symbol: string
  description: string
}

export type LegendEntry = LegendGroup | LegendKey

/**
 * Resolves the handler function for the keypress described by `ch` and `key`
 * as defined in `keyMap`
 *
 * @param keyMap The KeyMap to resolve the handler from
 * @param ch The character string, if any, generated by the keypress
 * @param key The key object generated by the keypress
 *
 * @return The handler function if a match was found, otherwise `undefined`
 */
export const keyHandler = (
  keyMap: KeyMap,
  ch: string | undefined,
  key: any
) => {
  const reKeys = Object.keys(keyMap).filter(
    (pt) => pt.startsWith('/') && pt.endsWith('/')
  )

  if (ch !== undefined) {
    for (const pattern of reKeys) {
      if (ch.match(new RegExp(pattern.substring(1, pattern.length - 1)))) {
        return keyMap[pattern].handler
      }
    }
  }

  return keyMap[key.full]?.handler
}

/**
 * Get the effective KeyMap of a component, including entries that
 * would be caught by event bubbling.
 *
 * @param controller The controller to get the effective keymap for
 * @returns The effective keymap
 */
export const getEffectiveKeyMap = (controller: Controller) => {
  let keyMap: KeyMap = {}

  let next: Controller | undefined = controller

  while (next) {
    keyMap = { ...next.keyMap, ...keyMap }
    next = next.parent
  }

  return keyMap
}

export interface KeystrokeLegend {
  categories: Record<string, Record<string, LegendEntry>>
}

export interface KeystrokeLegendOptions {
  initial?: KeystrokeLegend
  categories?: string[]
  keySymbols?: Record<string, string>
}

/**
 * Generate a KeystrokeLegend for `controller`, collecting all active
 * keymappings of the component and its parents.
 *
 * An initial KeystrokeLegend can be provided, including global level defaults
 * or mappings otherwise not readable from the component hierarchy.
 *
 * The legend is divided into categories according to the individual
 * KeyMappings of the effective KeyMap. KeyMappings that do not specify a
 * category will be collected in the `default` category.
 *
 * Categories can be limited to a specific set if `options.categories` is
 * provided. Any KeyMapping specifying a category not present in the
 * `options.categories` will then be grouped into `default`.
 *
 * A map of key symbol substitutions can be provided in `keySymbols`, in which
 * case any matching key will appear in the result as the substitute string.
 * This can, for example, be used to replace `up` and `down` with arrow icons.
 *
 * @param controller The controller to generate the legend for
 * @param opts Options for legend generation
 * @return The generated KeystrokeLegend
 */
export const generateKeystrokeLegend = (
  controller: Controller,
  opts: KeystrokeLegendOptions = { keySymbols: {} }
) => {
  const { initial, categories, keySymbols = {} } = opts

  const result: KeystrokeLegend = initial
    ? mergeLeft({}, initial)
    : { categories: {} }

  const keyMap = getEffectiveKeyMap(controller)

  for (const [key, mapping] of Object.entries(keyMap)) {
    const {
      legend,
      group,
      category = 'default',
    } = typeof mapping === 'function' ? {} : mapping

    if (!legend) continue

    const effectiveCategory = categories
      ? categories.includes(category)
        ? category
        : 'default'
      : category

    const legendCategory: Record<string, LegendEntry> = (result.categories[
      effectiveCategory
    ] ??= {})

    if (group) {
      const gr = (legendCategory[group] ??= {
        symbol: '',
        description: group,
      })
      gr.symbol += keySymbols[key] ?? key
    } else {
      legendCategory[key] = {
        symbol: keySymbols[key] ?? key,
        description: legend,
      }
    }
  }

  return result
}
